\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.5in]{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\hypersetup{
    colorlinks = true,
    linkcolor = blue
}

\lstset{frame=tb,
   language=Java,
   aboveskip=3mm,
   belowskip=3mm,
   showstringspaces=false,
   columns=flexible,
   basicstyle={\small\ttfamily},
   numbers=none,
   numberstyle=\tiny\color{gray},
   keywordstyle=\color{blue},
   commentstyle=\color{dkgreen},
   stringstyle=\color{mauve},
   breaklines=true,
   breakatwhitespace=true
   tabsize=3
   }
   
\title{CAB302 LECTURE NOTES}
\author{OOP Part 1 and 2 }
\date{Week 1 and 2}

\usepackage{natbib}
\usepackage{graphicx}

\begin{document}

\maketitle
\section{Console input and output}
\begin{itemize}
    \item Standard output is a character stream
    \begin{lstlisting}
        System.out.println("Hello, World!");
    \end{lstlisting}
    
    \item Standard output is a byte stream
    \begin{lstlisting}
        BufferedReader stdIn = new BufferedReader(new
        InputStreamReader(System.in));
        input = stdIn.readLine();
    \end{lstlisting}
    
    \item Java 6 introduced class \texttt{Console} to facilitate elegant input and output 
    
    \item To declare a console object:
    \begin{lstlisting}
        Console terminal = System.console();
    \end{lstlisting}
    
    \item Reading from the console:
    \begin{lstlisting}
    input = terminal.readLine();
    \end{lstlisting}
    
    \item Writing to the console:
    \begin{lstlisting}
    terminal.printf("Hello, World!");
    \end{lstlisting}
    
\end{itemize}

\section{Classes in Java}
\begin{itemize}
    \item Declare classes with the \texttt{class} keyword
    \item Declare objects with the \texttt{new} operator
\end{itemize}
Types of variables in java classes:
\begin{itemize}
    \item fields- declared in a class
    \item local variables- declared within a method
    \item parameters- passed to a method and part of a method's signature
\end{itemize}
Within a class the keyword \texttt{this} denotes the current object
\begin{itemize}
    \item \texttt{this()} invokes the constructor
    \item \texttt{this.field} accesses an instance field
    \item \texttt{this.method()} calls an instance method
\end{itemize}
The \texttt{static} qualifier means only one copy exists of the field or method

\section{Packages in Java}
\begin{itemize}
    \item Java packages are containers for functionally-related classes
    \item Each package has its own scope and name space
    \item Classes in different packages can be imported into other classes using the \texttt{import} keyword
    
\end{itemize}

\section{Encapsulation}
\begin{itemize}
    \item A design practice that separates specification (what it does and how to use it) from implementation (actual code)
    \item In Java, method signatures specify how methods should be called and what they return
    \item To obey the principles of abstraction and encapsulation of a class, you should:
    \begin{itemize}
        \item make fields \texttt{private}
        \item make \hyperref[itm:accessor]{\texttt{accessors}} and  \hyperref[itm:mutator]{\texttt{mutators}} \texttt{public}
        make helper methods \texttt{private}
    \end{itemize}
\end{itemize}

\section{Inheritance}
\begin{itemize}
    \item instantiated from from subclasses can do everything that superclass objects can and sometimes more
    \item They can also override some superclass characteristics
    \item In Java, inheritance is introduced in classes via the \texttt{extends} keyword for inheriting from superclasses
    \item a superclass' constructor (a subroutine that is called to create an object) is called with \texttt{super} and it's methods with \texttt{\textbf{super}.method()}
\end{itemize}    

\section{Finality}
The \texttt{final} keyword prevents 
\begin{itemize}
    \item a variable's value from being altered
    \item a class from being extended
    \item a method from being overridden
\end{itemize}

\section{Interfaces in Java}
\begin{itemize}
    \item In Java, an interface is a kind of class that contains \hyperref[itm:abstract]{\texttt{abstract}} methods only
    interfaces cannot be instantiated as objects, their abstract methods are incomplete and cannot be executed 
    \item Use keyword \texttt{implements} for inheriting from interfaces
    \item all methods within an interface are \texttt{public} by default
\end{itemize}
Why use interfaces? 
\begin{itemize}
    \item each implementation is very different
    \item acts as contract- each implementing class HAS to provide implementation
    \item Multiple inheritance- a java class can only extend one class, but you can implement any number of interfaces
\end{itemize}

\section{Abstract classes in Java}
\begin{itemize}
    \item An abstract class implements some member fields and methods but leaves others abstract
    \item abstract methods are indicated  by the \texttt{abstract} keyword
    \item child class must implement abstract classes but don't have to implement non-abstract classes
    \item like interfaces, abstract classes cannot be instantiated
\end{itemize} 
Why use Abstract classes? 
\begin{itemize}
    \item code reuse
    \item polymorphism
    no need for subclasses to implement non-abstract
\end{itemize}


\section{Polymorphism}
\begin{itemize}
    \item Apply the same operation on different types with a common ancestor in the type hierarchy 
    \end{itemize}

\section{Enum types}
\begin{itemize}
    \item special kind of class whose fields are \texttt{named constants}
    \item enums have an implicit \texttt{values} method- can be used in for loop
    \item java allows \texttt{enum} classes to have other fields and methods, apart from the constants
    \begin{lstlisting}
    // Enum class example
    
        public enum Planet{
            MERCURY (3.7),
            VENUS (8.87),
            EARTH (9.799);
            
            double gravity;
            Planet(double gravity)
            {
                this.gravity = gravity;
            }
            
            public double getGravity()
            {
                return gravity;
            }
            
            public static void main(String[] args) 
            {
                for (Planet p : Planet.values())
                {
                    System.out.println(p.getGravity());
                }
            }
        }
    \end{lstlisting}
\end{itemize}


\section{Other Definitions}
\begin{itemize}
    \item \label{itm:accessor} \scalebox{1.5}{\texttt{Accessors}} are methods used to return the value of a private field. An accessor is declared as public. The naming scheme of accessors is \texttt{getNameOfReturnValue}. The data type of an accessor is the same as their returning private field.


    \item \label{itm:mutator} \scalebox{1.5}{\texttt{Mutator}} methods change things. Mutators are declared as public. Mutators do not have a return type, instead they set the value of the private field. They also  accept a parameter of the same data type as the private field they are modifying. The naming scheme of mutators is \texttt{set  nameOfModifiedValue}.

    \begin{lstlisting}
        // Accessors and Mutators Example
        public class Cat 
        {  
            private int Age;  
            public int getAge() 
            {  
                return this.Age;  
            }  
            public void set Age(int Age) 
            {  
                this.Age = Age;  
            }  
        }
        // OR
        public class Employee 
        {  
            private int number; 
            // this is the accessor method
            public int getNumber() {  
                return number;  
            }  
            public void setNumber(int newNumber) {  
                number = newNumber;  
            }  
        } 
    \end{lstlisting}
    
     \item \label{itm:abstract} \scalebox{1.5}{\texttt{Abstract}} methods are specifications, consisting of a signature but no body
     
    \begin{lstlisting}
        // Abstract methods Example
        public interface GraphicalEntity 
        {  
        
            public float getArea();

            public float getPerimeter();
        }
        
        // INHERITING INTERFACES EXAMPLE
        public class Rectangle implements
            GraphicalEntity 
            {
                float length;
                float width;
                
                public Rectangle(float l, float w)
                {
                length = l;
                width = w;
                }
                
                public float getArea()
                {
                return length * width;
                }
                
                public float getPerimeter()
                {
                return length + width * 2;
                }
            }

    \end{lstlisting}
\end{itemize}

\end{document}
